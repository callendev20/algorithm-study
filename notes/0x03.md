### 0x03강 - 배열

- 배열의 성질 
   1. O(1)에 k번째 원소를 확인/변경 가능하다.
   2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음.
   3. Cache hit rate가 높음.
   4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림.

- 임의의 위치에 원소를 추가, O(N)
  - 추가하는 원소의 위치가 뒤에 가까울 수록 적게 밀고, 앞에 가까울 수록 더 많이 뒤로 밀어야 하겠지만 평균적으로는 N/2개를 밀어야한다. 
   => O(N)

- 임의의 위치에 원소를 제거, O(N)
  - 제거하는 원소를 빼고, 뒤의 원소들을 앞으로 한 칸씩 당겨야 한다.
  - 제거하는 원소만 쏙 뺴면 다음에 원소를 찾을 때 O(1)이 아니므로 배열의 성질에 위배된다.

- 마지막 원소를 추가/제거 하는 것은 O(1)이다.

- 배열 사용 팁
  - 배열을 채우는 방법
   ```c++
   int a[21];
   int b[21][21];

   // 짧지만, 0이 아닌 다른 숫자를 넣었을 때 오작동 가능성. 비추천
   memset(a,0,sizeof a);
   memset(b,0,sizeof b);

   //포문과 이중포문으로 일일이 채우는 법. 무난함

   // algorithm 헤더에 있는 함수. 익숙해지면 코드도 짧고 좋다. 추천.
   fill(a,a+21,0);
   for(int i = 0; i < 21; i++)
      fill(b[i],b[i]+21,0);
   ```
   
- STL vector
  - 참고할 점
    - vector.insert(위치,값) 을 했을 때 시간 복잡도는 O(N)이다. 오인하고 시간복잡도를 잘못 생각하는 일이 없도록 하자.
    - vector에서 = 오퍼레이터를 사용하게 되면 deep copy가 발생하게 된다. 
    - vector을 순회할 떄.
   ```c++
   vector<int> v1 = {1,2,3,4,5,6};
   // 1. range-based for loop (since C++11)
   for(int e : v1)
      cout << e << ' ';
   // 2. not bad
   // 걍 포문으로 도는거. v1.size() 써서.
   ```
   - range-based for loop 쓸 떄 int& e : v1 했으면, e값을 바꾸면 v1의 해당 값도 변한다.
   - 유일하게 삼성전자 SW역량 테스트에서 c++11을 지원해주지 않았다. 확인 필요.
   - 중요!!!!!!!!
     - 포문으로 돌 때 범위를 i <= v1.size()-1 로 하면 안된다.
     - v1.size()는 unsigned int를 반환하는데, v1이 빈 벡터일 떄 v1.size()-1 이 unsigned int 0 에서 int 1을 빼는 식이 되고, unsigned int와 int를 연산하면 unsigned int로 자동 형변환이 되기 때문에 -1이 아니라 4294967295가 된다. unsigned int 오버플로우로 인해 발생한거다.
